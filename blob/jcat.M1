; register use
; s2: pointer to input buffer
; s3: pointer to output buffer
; s4-s5 reserved for hex0
; s6: getchar counter
; s7: total number of bytes read from stdin
; s8: putchar counter

DEFINE sha_state_init '6a09e667bb67ae853c6ef372a54ff53a510e527f9b05688c1f83d9ab5be0cd19'

:_start
    rd_sp ~0x200400 lui            ; zkvm-specific per risc0/zkvm/platform/src/memory.rs
    rd_sp rs1_sp !0x200400 addi

    # allocate buffers: 1 sha2 block working space + 1 block reserved for padding
    rd_s2 rs1_sp !-128 addi
    rd_sp rs1_sp !-128 addi
    rd_s3 rs1_sp !-128 addi
    rd_sp rs1_sp !-128 addi

    :loop
    rd_ra !getchar jal
    rs1_a0 @end_loop bltz
    rd_ra !putchar jal
    @loop beq

    :end_loop

    ; finalize stdin hashing
    ;; add terminating bit
    rd_t3 rs1_s6 !63 andi
    rd_t2 rs1_s2 rs2_t3 add # t2 = &input_buffer[s6 % 64]
    rd_t3 !0x80 mv
    rs1_t2 rs2_t3 sb

    ;; insert total length in bits
    ;; TODO handle len % 64 >= 56
    rd_t3 rs1_s6 !3 slli # number of bits
    rd_t2 rs1_s2 !63 addi
    rs1_t2 rs2_t3 sb
    rd_t2 rs1_t2 !-1 addi
    rd_t3 rs1_t3 srli !8
    rs1_t2 rs2_t3 sb
    rd_t2 rs1_t2 !-1 addi
    rd_t3 rs1_t3 srli !8
    rs1_t2 rs2_t3 sb
    rd_t2 rs1_t2 !-1 addi
    rd_t3 rs1_t3 srli !8
    rs1_t2 rs2_t3 sb

    rd_t0 !3 mv # `ecall::SHA`
    rd_a0 ~stdin_sha_state auipc # input sha state
    rd_a0 rs1_a0 !stdin_sha_state addi
    rd_a1 rs1_a0 mv # output sha state (= input)
    rd_a2 rs1_s2 mv # buffer
    rd_a3 rs1_a2 !32 addi
    rd_a4 !1 mv # block count
    ecall

    rd_t2 ~stdin_sha_state auipc
    rd_t2 rs1_t2 !stdin_sha_state addi
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 rs1_t2 mv
    rd_a1 !8 addi         # syscall buffer length in words
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !3 mv          # file descriptor
    rd_a4 rs1_t2 mv
    rd_a5 !32 mv         # Set length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    # FIXME writes zeroes
    rd_t2 ~stdin_sha_state auipc
    rd_t2 rs1_t2 !stdin_sha_state addi
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 rs1_t2 mv
    rd_a1 !8 addi         # syscall buffer length in words
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !3 mv          # file descriptor
    rd_a4 rs1_t2 mv
    rd_a5 !32 mv         # Set length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    # Halt syscall to terminate.
    rd_t0 !0 addi    # `ecall::HALT`
    rd_a0 !0 addi    # `halt::TERMINATE` with 0 exit code
    rd_a1 ~empty_journal_digest auipc    # Set output digest
    rd_a1 rs1_a1 !empty_journal_digest addi
    ecall                 # `ecall(t0, a0, a1)`
    ret             # unreachable, just for disassemblers

:getchar
    # read 1 character from stdin into a0
    nop

    rs1_s6 rs2_s7 @skip_read bne
    rd_t0 rs1_s7 !63 andi
    rs1_t0 @skip_read bnez

    ; here s6 == s7 && s7 % 64 == 0
    rs1_s7 @skip_compress beqz

    ; here s6 == s7 && s7 % 64 == 0 && s7 != 0
    rd_t0 !3 mv # `ecall::SHA`
    rd_a0 ~stdin_sha_state auipc # input sha state
    rd_a0 rs1_a0 !stdin_sha_state addi
    rd_a1 rs1_a0 mv # output sha state (= input)
    rd_a2 rs1_s2 mv # buffer
    rd_a3 rs1_a2 !32 addi
    rd_a4 !1 mv # block count
    ecall

    :skip_compress
    ; here s6 == s7 && s7 % 64 == 0
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 rs1_s2 mv
    rd_a1 !16 addi         # syscall buffer length in words
    rd_a2 ~sys_read auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_read addi
    rd_a3 !0 addi          # Set file to `STDIN_FILENO`
    rd_a4 rs1_s2 mv
    rd_a5 !64 addi         # Set read length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    ; add count of read bytes to s7
    rd_s7 rs1_a0 rs2_s7 add

    :skip_read
    ; execution always reaches here
    rs1_s6 rs2_s7 @skip_eof bne

    ; here s6 == s7
    rd_a0 !-1 addi # a0 = -1 (EOF)
    ret

    :skip_eof
    ; here s6 < s7
    rd_t3 rs1_s6 !63 andi  # t3 = s6 % 64
    rd_t2 rs1_s2 rs2_t3 add # t2 = input_buffer + t3
    rd_a0 rs1_t2 lb # a0 = *(char*)t2
    rd_s6 rs1_s6 !1 addi # s6 += 1
    ret

:putchar
    nop
    # (eventually) put (char)a0 onto stdout
    rd_t2 rs1_sp !-4 addi
    rs1_t2 rs2_a0 sb

    # write 1 byte
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 rs1_t2 mv
    rd_a1 !1 addi         # syscall buffer length in words
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !1 mv          # file descriptor
    rd_a4 rs1_t2 mv
    rd_a5 !1 mv         # Set read length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    ret



:empty_journal_digest
    '836f175c62c0f353831665427e8b0b34f6d1d21902764daeb406c6b83db575b0'

## global variables

:stdin_sha_state
    sha_state_init

#
## Null-terminated `read` syscall name
:sys_read
    "risc0_zkvm_platform::syscall::nr::SYS_READ"

:sys_write
    "risc0_zkvm_platform::syscall::nr::SYS_WRITE"

:ELF_end
