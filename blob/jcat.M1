; register use
; s2: pointer to input buffer
; s3: pointer to output buffer
; s4-s5 reserved for hex0
; s6: getchar counter
; s7: total number of bytes read from stdin
; s8: putchar counter

DEFINE sha_state_init '6a09e667bb67ae853c6ef372a54ff53a510e527f9b05688c1f83d9ab5be0cd19'

:_start
    rd_sp ~0x200400 lui            ; zkvm-specific per risc0/zkvm/platform/src/memory.rs
    rd_sp rs1_sp !0x200400 addi

    # allocate buffers: 1 sha2 block working space + 1 block reserved for padding
    rd_s2 rs1_sp !-128 addi
    rd_sp rs1_sp !-128 addi
    rd_s3 rs1_sp !-128 addi
    rd_sp rs1_sp !-128 addi

    :loop
    rd_ra !getchar jal
    rs1_a0 @end_loop bltz
    rd_ra !putchar jal
    @loop beq

    :end_loop

    ; assumption: getchar() returns EOF so the buffer contains up to 63 bytes of data
    rd_a0 ~stdin_sha_state auipc
    rd_a0 rs1_a0 !stdin_sha_state addi
    rd_a1 rs1_s2 mv
    rd_a2 rs1_s6 mv
    rd_ra !sha_finalize jal

    rd_t2 ~stdin_sha_state auipc
    rd_t2 rs1_t2 !stdin_sha_state addi
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 !0 mv
    rd_a1 !0 mv
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !3 mv          # file descriptor
    rd_a4 rs1_t2 mv
    rd_a5 !32 mv         # Set length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`


    # flush output buffer
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 !0 mv
    rd_a1 !0 mv
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !1 mv          # file descriptor
    rd_a4 rs1_s3 mv
    rd_a5 rs1_s8 !63 andi
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    ; finalize output hash
    rd_a0 ~stdout_sha_state auipc
    rd_a0 rs1_a0 !stdout_sha_state addi
    rd_a1 rs1_s3 mv
    rd_a2 rs1_s8 mv
    rd_ra !sha_finalize jal

    #; debug print buffer
    #rd_t2 rs1_s3 addi
    #rd_t0 !2 addi # `ecall::SOFTWARE`
    #rd_a0 !0 mv
    #rd_a1 !0 mv
    #rd_a2 ~sys_write auipc  # Set syscall name C string
    #rd_a2 rs1_a2 !sys_write addi
    #rd_a3 !1 mv          # file descriptor
    #rd_a4 rs1_t2 mv
    #rd_a5 !128 mv         # Set length
    #ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    rd_t2 ~stdout_sha_state auipc
    rd_t2 rs1_t2 !stdout_sha_state addi
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 !0 mv
    rd_a1 !0 mv
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !3 mv          # file descriptor
    rd_a4 rs1_t2 mv
    rd_a5 !32 mv         # Set length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    # Halt syscall to terminate.
    rd_t0 !0 addi    # `ecall::HALT`
    rd_a0 !0 addi    # `halt::TERMINATE` with 0 exit code
    rd_a1 ~empty_journal_digest auipc    # Set output digest
    rd_a1 rs1_a1 !empty_journal_digest addi
    ecall                 # `ecall(t0, a0, a1)`
    ret             # unreachable, just for disassemblers

:getchar
    # read 1 character from stdin into a0
    nop

    rs1_s6 rs2_s7 @skip_read bne
    rd_t0 rs1_s7 !63 andi
    rs1_t0 @skip_read bnez

    ; here s6 == s7 && s7 % 64 == 0
    rs1_s7 @skip_compress beqz

    ; here s6 == s7 && s7 % 64 == 0 && s7 != 0
    rd_t0 !3 mv # `ecall::SHA`
    rd_a0 ~stdin_sha_state auipc # input sha state
    rd_a0 rs1_a0 !stdin_sha_state addi
    rd_a1 rs1_a0 mv # output sha state (= input)
    rd_a2 rs1_s2 mv # buffer
    rd_a3 rs1_a2 !32 addi
    rd_a4 !1 mv # block count
    ecall

    :skip_compress
    ; here s6 == s7 && s7 % 64 == 0
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 rs1_s2 mv
    rd_a1 !16 addi         # syscall buffer length in words
    rd_a2 ~sys_read auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_read addi
    rd_a3 !0 addi          # Set file to `STDIN_FILENO`
    rd_a4 rs1_s2 mv
    rd_a5 !64 addi         # Set read length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    ; add count of read bytes to s7
    rd_s7 rs1_a0 rs2_s7 add

    :skip_read
    ; execution always reaches here
    rs1_s6 rs2_s7 @skip_eof bne

    ; here s6 == s7
    rd_a0 !-1 addi # a0 = -1 (EOF)
    ret

    :skip_eof
    ; here s6 < s7
    rd_t3 rs1_s6 !63 andi  # t3 = s6 % 64
    rd_t2 rs1_s2 rs2_t3 add # t2 = input_buffer + t3
    rd_a0 rs1_t2 lb # a0 = *(char*)t2
    rd_s6 rs1_s6 !1 addi # s6 += 1
    ret

:putchar
    nop
    # (eventually) put (char)a0 onto stdout
    rd_t2 rs1_s8 !63 andi
    rd_t2 rs1_s3 rs2_t2 add # output_buffer + (s8 % 64)
    rs1_t2 rs2_a0 sb
    rd_s8 rs1_s8 !1 addi

    rd_t2 rs1_s8 !63 andi
    rs1_t2 @skip_flush bnez

    ; here s8 % 64 == 0
    # write out the buffer and compress
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 !0 mv
    rd_a1 !0 mv
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !1 mv          # file descriptor
    rd_a4 rs1_s3 mv
    rd_a5 !64 mv
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    rd_t0 !3 mv # `ecall::SHA`
    rd_a0 ~stdout_sha_state auipc # input sha state
    rd_a0 rs1_a0 !stdout_sha_state addi
    rd_a1 rs1_a0 mv # output sha state (= input)
    rd_a2 rs1_s3 mv # buffer
    rd_a3 rs1_a2 !32 addi
    rd_a4 !1 mv # block count
    ecall
    
    :skip_flush
    ret

:sha_finalize
    ; arguments
    ; a0: sha state (in and out)
    ; a1: buffer (in, 128 bytes spaces, contains at most 63 bytes incomplete block)
    ; a2: total_bytes
    ; local variables
    ; a4 block count
    nop

    ; add terminating bit
    rd_t2 rs1_a2 !63 andi
    rd_t2 rs1_a1 rs2_t2 add # t2 = &buffer[total_bytes % 64]
    rd_t3 !0x80 mv
    rs1_t2 rs2_t3 sb # *t2 = 0x80

    ; insert total length in bits
    rd_a4 !1 mv # block count
    rd_t2 rs1_a2 !63 andi
    rd_t3 !56 mv
    rs1_t2 rs2_t3 @skip_increase_block_count blt
    ; here total_bytes % 64 >= 56
    ; we will need an extra sha2 block to put the bit length
    rd_a4 !2 mv

    :skip_increase_block_count
    ; insert bit length
    ; NOTE breaks at 2^29 bytes
    rd_t3 rs1_a2 !3 slli
    rd_t2 !64 mv
    rd_t2 rs1_a4 rs2_t2 mul
    rd_t2 rs1_a1 rs2_t2 add ; t2 = buffer[block_count*64]
    rd_t2 rs1_t2 !-1 addi
    rs1_t2 rs2_t3 sb
    rd_t3 rs1_t3 !8 srli
    rd_t2 rs1_t2 !-1 addi
    rs1_t2 rs2_t3 sb
    rd_t3 rs1_t3 !8 srli
    rd_t2 rs1_t2 !-1 addi
    rs1_t2 rs2_t3 sb
    rd_t3 rs1_t3 !8 srli
    rd_t2 rs1_t2 !-1 addi
    rs1_t2 rs2_t3 sb

    ; compress
    # a0 already contains sha_state
    # a4 already contains block count
    rd_t0 !3 mv # `ecall::SHA`
    rd_a2 rs1_a1 mv # buffer
    rd_a1 rs1_a0 mv # output sha state (= input)
    rd_a3 rs1_a2 !32 addi
    ecall
    ret



:empty_journal_digest
    '836f175c62c0f353831665427e8b0b34f6d1d21902764daeb406c6b83db575b0'

## global variables

:stdin_sha_state
    sha_state_init

:stdout_sha_state
    sha_state_init

#
## Null-terminated `read` syscall name
:sys_read
    "risc0_zkvm_platform::syscall::nr::SYS_READ"

:sys_write
    "risc0_zkvm_platform::syscall::nr::SYS_WRITE"

:ELF_end
