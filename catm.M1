# M1 --architecture riscv32 --little-endian -f $M2libc/riscv32/riscv32_defs.M1 -f catm.M1 -o catm.hex2
# hex2 --architecture riscv32 --little-endian -f $M2libc/riscv32/ELF-riscv32.hex2 -f catm.hex2

:_start
    # Load loop iteration count word from stdin via `read` syscall
    #
    # NOTE: We don't check for errors since we assume the host will provide
    # correct input
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 !0 addi         # syscall buffer pointer
    rd_a1 !0 addi         # syscall buffer length in words
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !1 addi          # Set file to `STDOUT_FILENO`
    rd_a4 ~greeting auipc
    rd_a4 rs1_a4 !greeting addi
    rd_a5 !12 addi         # Set write length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    # Halt syscall to terminate.
    rd_t0 !0 addi    # `ecall::HALT`
    rd_a0 !0 addi    # `halt::TERMINATE` with 0 exit code
    rd_a1 ~digest auipc    # Set output digest
    rd_a1 rs1_a1 !digest addi    # Set output digest
    ecall                 # `ecall(t0, a0, a1)`
    ret             # unreachable, just for disassemblers

#
#.section .data
#
## Write Read buffer
:count
    NULL
#
#.section .rodata
#

:greeting "Hello world!\n"

:digest
    '836f175c62c0f353831665427e8b0b34f6d1d21902764daeb406c6b83db575b0'

#
## Null-terminated `read` syscall name
:sys_read
    "risc0_zkvm_platform::syscall::nr::SYS_READ"

:sys_write
    "risc0_zkvm_platform::syscall::nr::SYS_WRITE"

:ELF_end
