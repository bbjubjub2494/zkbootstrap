# M1 --architecture riscv32 --little-endian -f $M2libc/riscv32/riscv32_defs.M1 -f catm.M1 -o catm.hex2
# hex2 --architecture riscv32 --little-endian -f $M2libc/riscv32/ELF-riscv32.hex2 -f catm.hex2

:_start
    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 ~buffer auipc
    rd_a0 rs1_a0 !buffer addi
    rd_a1 !16 addi         # syscall buffer length in words
    rd_a2 ~sys_read auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_read addi
    rd_a3 !0 addi          # Set file to `STDIN_FILENO`
    rd_a4 ~buffer auipc
    rd_a4 rs1_a4 !buffer addi
    rd_a5 !64 addi         # Set write length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`
    rd_t1 rs1_a0 mv # return value

    rd_t0 !2 addi # `ecall::SOFTWARE`
    rd_a0 !0 addi         # syscall buffer pointer
    rd_a1 !0 addi         # syscall buffer length in words
    rd_a2 ~sys_write auipc  # Set syscall name C string
    rd_a2 rs1_a2 !sys_write addi
    rd_a3 !1 addi          # Set file to `STDOUT_FILENO`
    rd_a4 ~buffer auipc
    rd_a4 rs1_a4 !buffer addi
    #rd_a5 !64 addi         # Set write length
    rd_a5 rs1_t1 mv         # Set write length
    ecall                 # `ecall(t0, a0, a1, a2, a3, a4, a5)`

    # Halt syscall to terminate.
    rd_t0 !0 addi    # `ecall::HALT`
    rd_a0 !0 addi    # `halt::TERMINATE` with 0 exit code
    rd_a1 ~digest auipc    # Set output digest
    rd_a1 rs1_a1 !digest addi    # Set output digest
    ecall                 # `ecall(t0, a0, a1)`
    ret             # unreachable, just for disassemblers

#
#.section .data
#
## 64-byte buffer
:buffer
    "XXXXXXXX" "XXXXXXXX"
    "XXXXXXXX" "XXXXXXXX"
    "XXXXXXXX" "XXXXXXXX"
    "XXXXXXXX" "XXXXXXXX"
#
#.section .rodata
#

:greeting "Hello world!\n"

:digest
    '836f175c62c0f353831665427e8b0b34f6d1d21902764daeb406c6b83db575b0'

#
## Null-terminated `read` syscall name
:sys_read
    "risc0_zkvm_platform::syscall::nr::SYS_READ"

:sys_write
    "risc0_zkvm_platform::syscall::nr::SYS_WRITE"

:ELF_end
